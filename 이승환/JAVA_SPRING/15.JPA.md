**15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?**


JPA를 사용하면 SQL중심적 개발에서 객체 중심적인 개발에 집중할 수 있습니다. 기존에는 필드를 변경하면 모든 SQL문을 찾아가면서 변경해야 했지만 JPA를 사용하면 필드만 추가하면 JPA가 처리해줘 유지보수가 쉬워집니다.

- 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
    - 우선 영속성은 엔티티를 영구 저장하는 환경으로서 객체를 보관하는 가상의 데이터 베이스 같은 역할을 수행합니다.
    - **생산성 향상:** 객체 지향적인 방식으로 데이터베이스를 다룰 수 있어 개발 생산성을 높입니다.
    - **유지보수성 향상:** 객체 모델과 데이터베이스 구조를 일치시켜 코드 가독성을 높이고 유지보수를 용이하게 합니다.
    - **개발 편의성:** 복잡한 SQL 쿼리를 직접 작성할 필요 없이, 객체 지향적인 방법으로 데이터베이스를 조작할 수 있습니다.
    
    - **엔티티:** 데이터베이스 테이블과 매핑되는 자바 객체입니다.
    - **영속성 컨텍스트:** 엔티티를 관리하는 메모리 공간으로, 애플리케이션과 데이터베이스 사이의 중간 매개체 역할을 합니다.
    - 엔티티 매니저 : 엔티티의 구현체를 생명주기를 관리해준다.
    Entity 객체를 영속성 콘텍스트(persistence context)에 저장하여 관리한다.- 즉, Entity와 Persistence Context 사이에 존재하는 역할이다.
    - 엔티티의 생명주기
        - **영속 상태:** 영속성 컨텍스트에 관리되는 엔티티의 상태입니다. 영속 상태의 엔티티는 변경 사항이 발생하면 자동으로 데이터베이스에 반영됩니다.
        - **준영속 상태:** 영속성 컨텍스트에서 분리된 엔티티의 상태입니다. 더 이상 영속성 컨텍스트에 의해 관리되지 않습니다.
        - **비영속 상태:** 아직 영속성 컨텍스트에 저장되지 않은 엔티티의 상태입니다.
        
        ![img1.daumcdn.png](https://github.com/user-attachments/assets/6b44b9ce-c94e-484b-95f6-c1ece8bf4b50)
        
    - 엔티티 매니저
        - Entity를 영속성 컨텍스트에 등록하면 1차캐시에 등록이 된다.
        - 영속성 컨택스트 내부에 1차 캐시 라는 것이 있습니다. 데이터 베이스의 기본키를 식별자 값으로 갖고 값은 엔티티 인스턴스로가져 이를 사용하여 조회 하게 됩니다. 이러한 캐싱으로 데이터베이스 접근을 최소화할 수 있습니다.
        - 하지만 1차 캐시가 있는 EntityManager는 트랜잭션 단위로 만들고 사라진다. 즉, 1차 캐시가 살아있는 시간은 매우 짧아 성능에 큰 효과는 없다.
        - 2차캐시 : 애플리케이션 전체가 공유하는 캐시
        - 영속된 Entity의 동일성 보장 : 하나의 트랜잭션 동안 동일한 객체를 여러번 조회하면 이를 같은 값으로 처리,
        
        ```java
             User a = em.find(userA);
              User b = em.find(userA);
              System.out.println(a == b); // true 반환
        ```
        
        원래는 다른 주소 값이지만
        
        jpa는 조회되는 동일한 객체에 대해서 같은 객체로 처리
        
        동일한 sql반복해서 수행하면 db로 부터 값 조회하지 않고 1차 캐시에서 조회
        
    - 지연 로딩 : 엔티티 DB에서 가져올때 만약 연관관계를 가진 다른 객체를 가지고 있다면 연관된 객체도 함께 DB에서 조회, 프록시 객체로 가져온다.
    - 쓰기 지연 : 한 트랜잭션 안에서 DB에 보낼 쿼리문을 모았다가 한번에 보내어 네트워크 부하를 줄여주기 위한 기능입니다. commit()하기 전가지 sql작성하지않는다.
- N + 1 문제에 대해 설명해 주세요.
    - N + 1문제는 이해하기 쉽게 설명하자면 1 + N 문제라고 이야기 할 수 있습니다. 1개의 요청 쿼리로 처리 되길 기대했는데 N개의 추가 쿼리가 발생하는 상황입니다.
    - 연관 관계에서 발생하는 이슈로 연관관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽으면서 발생하는 문제
    - 해결방법으로는 Fetch Join이 있습니다. 연관된 엔티티나 컬렉션을 한번에 조회해서 영속성 컨텍스트에 전부 올려버립니다. 즉 한꺼번에 가져오는 기능입니다. 한번에 가져와 객체화를 해주어 DB를 거치지 않고 데이터 꺼내서 반환해줍니다.
    - 즉시 로딩과 fetch join의 차이?
    - 지연로딩때 batch사이즈 설정 ( n을 줄여준다.)
    - fetch join - inner join ,  outer join - entity graph
