
**16. @Transactional 은 어떤 기능을 하나요?**

선언적 트랜잭션으로 소스코드에 트랜잭션 관련 로직을 넣어두지 않고 비지니스 로직에서 완전히 분리하는 방식

프로그래밍에 의한 트랙잭션에서 나온 단점인 트랜잭션 코드 중복 문제, 소스코드 유지보수의 문제 해결 가능.

트랜잭션이라는 횡단 관심사를 비지니스 로직에서 완전히 부닐하기 때문에 SRP관점에서 봤을때도 적합하고 많은 양의 트랜잭션로직을 적용하기에도 합리적이다.

@Transactional을 메소드 또는 클래스에 명시하면 AOP를 통해 Target이 상속하고 있는 인터페이스 또는 Target객체를 상속한 Proxy 객체가 생성되며, Proxy 객체의 매소드를 호출하면 Targe메소드 전 후 로 트랜잭션 처리를 수행한다.

- @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
    - readonly 속성을 통해 트랜잭션을 읽기 전용으로 설정할 수 있다.
    - 영속성 컨텍스트는 Entity 조회 시 초기 상태에 대한 Snapshot(1차 캐시 내부에 존재)을 저장한다.
        - 왜 스냅샷을 사용하는가?
            - **효율적인 변경 감지:** 스냅샷을 저장해 두면, 엔티티의 모든 속성을 일일이 비교할 필요 없이 변경된 속성만 확인할 수 있습니다.
            - **데이터 일관성 유지:** 트랜잭션 내에서 발생한 모든 변경 사항이 일괄적으로 처리되므로 데이터베이스의 일관성을 유지할 수 있습니다.
    - 트랜잭션이 Commit 될 때, 초기 상태의 정보를 가지는 Snapshot과 Entity의 상태를 비교하여 변경된 내용에 대해 update query를 생성해 쓰기 지연 저장소에 저장한다.
    - 그 후, 일괄적으로 쓰기 지연 저장소에 저장되어 있는 SQL query를 flush 하고 데이터베이스의 트랜잭션을 Commit 함으로써 우리가 update와 같은 메서드를 사용하지 않고도 Entity의 수정이 이루어진다. 이를 변경 감지(Dirty Checking) 라고 한다.
        - 더티 체킹
            
            ### 더티 체킹 과정
            
            1. **엔티티 수정:** 개발자가 엔티티의 속성 값을 변경합니다.
            2. **스냅샷 비교:** JPA는 변경된 엔티티를 감지하고, 스냅샷과 비교하여 값이 변경되었는지 확인합니다.
            3. **변경 감지:** 만약 값이 변경되었다면, 해당 엔티티는 "더티" 상태로 표시됩니다.
            4. **트랜잭션 커밋:** 트랜잭션이 커밋될 때, JPA는 더티 상태인 모든 엔티티에 대한 `UPDATE` SQL을 생성하고 데이터베이스에 반영합니다.
            
            ### 더티 체킹의 장점
            
            - **개발 편의성:** 개발자가 수동으로 `UPDATE` SQL을 작성할 필요가 없습니다.
            - **데이터 일관성:** 트랜잭션의 일관성을 보장합니다.
            
            ### 더티 체킹의 단점
            
            - **성능 오버헤드:** 많은 엔티티를 관리하는 경우, 스냅샷 비교에 따른 성능 오버헤드가 발생할 수 있습니다.
            - **복잡한 객체 관계:** 양방향 연관 관계나 상속 관계가 복잡한 경우, 더티 체킹 로직이 복잡해질 수 있습니다.
    - 이때 readonly를 설정하게 된다면 스프링 프레임 워크가 JPA 세션 플러시 모드는 Manul로 설정하게 되어 수동으로 flush를 호출하지 않으면 flush가 수행되지않는다
    - 따라서 조회용 데이터에 예상치 못한 수정을 방지 할 수 있다.
    - 또한 변경감지를 위한 SnapShot을 따로 보관하지 않아 메모리상 이점 을 얻을 수 잇다.
- 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
    - 일관성 유지 : 다른 트랜잭션에서 데이터를 수정중 일대에도 조회작업이동시에 실행되면 수정이 완료되기 전의 데이터를 읽을 수 있다. 따라서 조회작업에도 트랜잭션을 적용
    - 로드 밸런싱 : 특정작업이 많은 시간이 걸리는 경우 , 다수의 작업이 해당작업을참조하는 경우가 발생할 수 잇다. 이때 트랜잭션을 걸어 작업이 완료될때까지 조회 작업을 블록하여 일관된 데이터를 제공할 수 있다.
    - OSIV
    - [https://hungseong.tistory.com/74](https://hungseong.tistory.com/74)
