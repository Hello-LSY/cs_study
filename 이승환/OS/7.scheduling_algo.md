**7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**

선점형 스케줄링과 비선점형으로 나뉜다.

선점형

프로세스가 CPU를 할당 받아 실행중이더라도 I/O나 인터럽트가 발생한것도 아니고 모든 작업을끝내지도 않았는데 다른 프로세스가 CPU를 강제로 빼앗을 수 잇는 방식

CPU 처리 시간이 매우 긴 프로세스가 CPU사용 독점을 막을 수 있어 효율적인 운영이 가능하지만 잦은 스위칭으로 오버헤드가 많이 발생한다.

비선점형

선점형과 반대로 프로세스가 CPU를 점유하고 있다면 이를 빼앗을 수 없는 방식이다. 한 프로세스가 CPU를 점유했다면, I/O나 인터럽트가 발생 또는 프로세스가 종료될 때까지 다른 프로세스가 CPU를 점유하지 못하는 것이다.

---

1. FIST-COME, FIRST SERVERED
 **FCFS는 비선점형(Non-Preemptive) 스케줄링으로**, 먼저 온 프로세스가 먼저 CPU를 점유하는 방식이다.
2. Shortest-Job-First ( SJF)
가장짧게 수행되는 프로세스가 먼저 수행되는 방식
선점형 비선점형 모두 가능
비현실적, 프로세스의 CPU점유 시간을 알 수 없을 뿐더러 프로세스가 실행중에는 많은 변수 존재
점유 시간 알려면 실제로 수행하여 측정하는 수 밖에 없다.
3. Priority
우선순위가 높은 프로세스 먼저 선택되는 스케줄링 알고리즘
선점형 비선점형 모두 가능 Priority가 낮을 수록 우선 순위가 높다.
기아(Starvation) 문제점이있다. 프로세스가 CPU점유를 오랫동안 하지 못하는 현상, 우선 순위가 매우 낮은 프로세스가 있으면 그 프로세ㅔ스는 cpu를 점유를 계속 못할 수도
해결방법으로 Aging이 있는데 우선 순위가 낮은 프로세스가 기다리는 동안 일정 시간이 지나면 우선순위를 일정량 높여주는 방식
4. Round-Robin (RR)
Round-Robin은 일정 시간을 정하여 각각의 프로세스가 이시간동안만 수행하고 다시 대기 상택로 돌아가는 방식을 말한다. Round-Robin은 기본적으로 선점형(Preemptive)이다. 일정 시간이 끝나면 다른 프로세스로 Cpu점겨준다.

일정시간을 Time Quantum(Time Slice)라고 부른다. 일반적으로10~100msec 사이의 범위 
Time QUantum 의 크리에 따라 매우 의존적이다.  
**Time Quantum** 크기를 무한에 가깝게 설정한다면 **FCFS**와 동일하게 동작하고. 반대로, 매우 작게 설정하면 스위칭 오버헤드가 매우 커서 비효율 적이다. 즉 Time Quantum 값을 적당한 크기로 설정해줘야 한다.
5. **Multilevel Queue Scheduling:**
    - 여러 개의 큐를 사용하여 프로세스를 관리하는 방식입니다. 각 큐는 우선순위에 따라 정렬되며, 다양한 스케줄링 알고리즘을 적용할 수 있습니다.
6. **Multilevel Feedback Queue Scheduling:**
    - 다양한 우선순위의 큐를 사용하며, 프로세스가 큐를 이동하면서 우선순위를 변경하는 방식입니다. 동적으로 우선순위를 조절하여 다양한 종류의 작업에 적응할 수 있습니다.

- RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
    1. **짧은 Time Slice의 장점:**
        - 빠른 응답 시간: 짧은 Time Slice는 프로세스 간 전환을 빈번하게 수행하므로, 사용자에 대한 응답 시간이 빨라집니다.
        - 공정한 자원 분배: 모든 프로세스가 공평한 기회를 가지고 CPU를 사용할 수 있습니다.
    2. **짧은 Time Slice의 단점:**
        - 컨텍스트 스위칭 오버헤드: Time Slice가 짧을수록 프로세스 간 전환 횟수가 증가하며, 이로 인해 컨텍스트 스위칭 오버헤드가 발생할 수 있습니다. 이는 CPU 시간을 낭비하게 되어 성능 저하를 가져올 수 있습니다.
        - 스케줄러 오버헤드: 짧은 Time Slice로 인해 스케줄러가 더 자주 실행되어야 하므로, 스케줄러 자체의 오버헤드가 증가할 수 있습니다.
    3. **긴 Time Slice의 장점:**
        - 컨텍스트 스위칭 오버헤드 감소: Time Slice가 길어지면 프로세스 간 전환 횟수가 감소하므로, 컨텍스트 스위칭 오버헤드가 감소합니다.
        - CPU 시간 효율성 향상: 긴 Time Slice로 인해 각 프로세스가 더 많은 연속적인 CPU 시간을 사용할 수 있습니다.
    4. **긴 Time Slice의 단점:**
        - 응답 시간 증가: 긴 Time Slice는 각 프로세스가 CPU를 사용하는 시간이 길어지므로, 사용자에 대한 응답 시간이 증가할 수 있습니다.
        - 공정성 감소: 긴 Time Slice로 인해 CPU를 점유한 프로세스가 오랜 시간동안 다른 프로세스를 대기시키게 되어, 공정성이 감소할 수 있습니다.
- 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
    
    싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있는 경우, 가장 적합한 스케줄링 알고리즘은(Non-preemptive Scheduling)입니다. 비선점형 스케줄링은 프로세스가 CPU를 할당받으면 해당 프로세스가 종료되거나 대기 상태로 전환될 때까지 CPU를 계속 사용합니다.
    
    1. **단일 작업에 집중:** 비선점형 스케줄링은 한 번 CPU를 할당받은 프로세스가 CPU를 반납하기 전까지 계속 실행됩니다. 이는 상시로 돌아가야 하는 프로세스가 중간에 다른 프로세스로 교체되는 것을 방지하고, 해당 프로세스가 계속해서 실행되어야 하는 경우에 적합합니다.
    2. **컨텍스트 스위칭 최소화:** 비선점형스케줄링은 컨텍스트 스위칭이 발생하지 않거나 매우 적게 발생합니다. 컨텍스트 스위칭은 비용이 큰 작업이므로, 이를 최소화함으로써 시스템의 효율성을 높일 수 있습니다.
    3. **간단한 구현:** 비선점형스케줄링은 구현이 비교적 간단하며, 단일 스레드에서 실행되는 경우에는 별다른 우선순위 결정이나 타이머 인터럽트 등을 고려할 필요가 없습니다.
    
    비선점형스케줄링은 주로 실시간 시스템이나 임베디드 시스템에서 사용되며, 단일 작업이 중요하고 다른 프로세스 간의 우선순위나 교체가 필요하지 않을 때 적합합니다.
    
- 동시성과 병렬성의 차이에 대해 설명해 주세요.
    1. **동시성(Concurrency):**
        - 동시성은 여러 작업이 동시에 진행되는 것처럼 보이도록 하는 개념입니다. 시간적으로 겹칠 수 있지만, 실제로는 각 작업이 동시에 실행되는 것은 아닙니다. 여러 작업이 번갈아 가며 조금씩 진행되어 마치 동시에 진행되는 것처럼 보입니다.
        - 동시성은 단일 프로세서에서 여러 작업을 처리하거나, 여러 프로세서 간에 작업을 나누어 처리하는 등의 상황에서 발생할 수 있습니다. 이는 주로 멀티태스킹, 이벤트 기반 프로그래밍 등에 적용됩니다.
    2. **병렬성(Parallelism):**
        - 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 의미합니다. 여러 개의 프로세서 또는 코어를 사용하여 각각의 작업을 병렬로 처리함으로써 성능을 향상시킵니다.
        - 병렬성은 동시성을 포함하는 개념으로, 동시에 여러 작업이 진행되는 것뿐만 아니라 실제로 병렬로 실행되는 것을 강조합니다. 이는 대규모 데이터 처리, 과학 및 엔지니어링 계산, 그래픽 처리 등에 사용됩니다.
- 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?
    1. **스타베이션(Starvation):**
        - 일부 프로세스가 계속해서 높은 우선순위로 실행되면서 다른 프로세스들이 낮은 우선순위로 계속해서 대기하는 상황을 스타베이션(Starvation)이라고 합니다. Multi-level Feedback Queue는 프로세스의 우선순위를 동적으로 조절하며, 오랜 시간동안 대기한 프로세스의 우선순위를 높여서 스타베이션을 완화할 수 있습니다.
    2. **응답 시간 향상:**
        - 일부 스케줄링 알고리즘은 응답 시간을 보장하기 어려운 경우가 있습니다. Multi-level Feedback Queue는 우선순위를 동적으로 조절하여 응답 시간을 개선할 수 있습니다. 우선순위를 낮게 유지하던 프로세스가 계속해서 대기하면 우선순위를 높여서 빠른 응답을 가능하게 합니다.
    3. **다양한 작업 부하 처리:**
        - Multi-level Feedback Queue는 다양한 큐를 사용하고, 각 큐에는 서로 다른 우선순위를 할당합니다. 이는 CPU 부하의 다양성을 처리하는 데 도움이 되며, CPU 사용량이 많은 프로세스와 입출력 작업이 많은 프로세스를 공정하게 다룰 수 있습니다.
    4. **유연한 스케줄링:**
        - Multi-level Feedback Queue는 동적으로 우선순위를 조절하며 여러 큐를 사용하여 프로세스를 관리하기 때문에, 다양한 작업 부하 및 우선순위의 변화에 유연하게 대응할 수 있습니다.
- FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?
    1. **단순한 환경:** FIFO 스케줄러는 구현이 간단하며, 운영체제가 간단한 환경에서 동작할 때 사용될 수 있습니다.
    2. **우선순위가 중요하지 않은 경우:** 프로세스의 우선순위가 중요하지 않고, 도착한 순서대로 처리해도 문제가 없는 경우에 사용될 수 있습니다.
    3. **프로세스의 실행 시간이 비슷한 경우:** 모든 프로세스의 실행 시간이 비슷하고, 도착한 순서대로 처리해도 성능에 큰 영향을 주지 않는 경우에 유용할 수 있습니다.
- 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
    - **프로세스 스케줄링과 스레드 스케줄링은 할당 대상만 다를 뿐 방식은 동일하다**
- 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?
    - 유저 스레드는 커널이 아닌 사용자 공간에서 관리되므로, 스케줄링이 더 빠르고 가볍지만, 커널이 아닌 사용자 레벨의 스레드 라이브러리에서 관리되기 때문에 블록된 스레드가 전체 프로세스에 영향을 미칠 수 있습니다.
        
        반면 커널 스레드는 커널이 개별적으로 관리하여 보다 세밀한 제어가 가능하고, 스레드가 독립적으로 관리되기 때문에 블록된 스레드가 다른 스레드에 영향을 미치지 않습니다. 다만, 커널에서 관리로 인해 스케줄링 오버헤드가 더 큽니다.
        
        > 유저스레드가 더 빠른 이유 : 유저 스레드 라이브러리 자체가 스레드의 레지스터 상태, 스택 포인터 등을 저장하고 복구하는 방식으로 전환. 이 과정은 커널 모드로 전환되지 않고, 유저 모드에서 이루어지기 때문에 상대적으로 가볍고 빠르다.
        >