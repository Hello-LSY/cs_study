**8. 뮤텍스와 세마포어의 차이점은 무엇인가요?**

뮤텍스는 공유된 자원의 데이터 혹은 임계영역 등에 하나의 프로세스 혹은 스레드가 접근하는 것을 막아주고

세마 포어는 공유된 자원의 데이터 혹은 임계영역등에  여러 프로세스 혹은 스레드가접근하는 것을 막아준다.

 뮤텍스는 하나의 프로세스에 의해 소유 될 수 있는 KEY를 기반으로 한 상호 배제 기법, 키에 해당하는 객체가 있고 이 객체를 소유한 스레드, 프로세스만 공유 자원에 접근 가능

세마포어는 사용하고 있는 스레드, 프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호 배제 공유자원에 접근할 수 잇는 프로세스의 최대 허용치 만큼 동시에 사용자가 접근 할 수 있다.

각 프로세스는 세마포어의 값을 확인하고 변경할 수 있습니다.
자원을 사용하지 않는 상태가 될 때, 대기하던 프로세스가 즉시 자원을 사용하고. 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면, 재시도 전에 일정시간 대기해야 합니다.

뮤텍스는 동기화 대상이 오직 1개일때, 세마포어는 동기화 대상이 1개 이상일때

뮤텍스는 자원을 소유할 수 잇고 책임을 가지는 반면, 세마포어는 자원 소유가 불가능

뮤텍스는 소유자가 0,1 상태 해제를 할 수 있고, 세마포어는 세마 포어를소유하지 않은 스레드가 세마 포어 해제 가능하다.

세마포어는 시스템 범위에 걸쳐 잇고  파일 시스템 상 파일로 존재, 뮤텍스는 프로세스 범위, 프로세스 종료 될때 Clean up 

<aside>
💡

세마 포어 동기화 어떻게 

</aside>

- 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.
    - 바이너리 세마포어는 0과 1만 가지는 세마포어이다.상호 배제를 위해 신호 전달 매커니즘을 사용해서 잠금을 구현
    - 락을 걸지않은 스레드도 signal을 이용해 락을 해제 할 수 잇따.
    - 현재 스레드보다 우선 순위가 높은 스레드가 바이너리 세마포어를 해제하고 잠글 수 있다.
    - 뮤텍스는 상호배제를 locking과 unlocking으로 락을 걸은 스레드 만이 임계영역을 나갈때 락 해제 가능
- Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

https://hogwart-scholars.tistory.com/entry/OS-Spin-Lock-%EC%8A%A4%ED%95%80%EB%9D%BD%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

- 스핀락은 대기중인 스레드가 공유중인 자원의 상태를 무한 루프를 이용해서 확인하는 방식

<aside>
💡

누가 계속 반복 돌리나요?

**스레드 상태**:

- Spin Lock을 기다리는 스레드는 **사용자 모드(user mode)**에서 실행을 계속합니다.
- 운영 체제의 스케줄러가 개입하지 않으므로 다른 스레드로 전환되지 않습니다.
</aside>

- OS의 스케줄링 지원을 받지 않기에 context switching이 일어나지 않는다는 특징이 잇다.
- 따라서 문맥 교환에 필요한 CPU의 오버헤드를 줄일 수 있다 (문맥 교환 중엔 어떤 작업을 수행할 수 없음)
- 락의 획득이 빠르다 (무한 루프 속에서 반복해서 락을 확인하기 때문)
- 락의 획득까지 무한 루프하기 때문에 CPU를 많이 잡아먹는다.
- 임계영역이 하나가 아니라 여러개라면, 락이 반환될때까지 오래 걸린다면
- Busy waiting: 스레드의 획득을 위해 CPU의 오버헤드가 발생할 수 잇따. - 무한 루프에 돌면서 CPU사용 계속 함
- Starvation (기아 상태) :  특정 스레드나 프로세스가 공유 자원을 오랫동안 점유한다면, 다른 스레드가 대기 상태에 걸릴 수 있다.

<aside>
💡

그럼 spin lock이 돌고 있으면 돌고 있는 스레드는 비선점형인가?

- **Spin Lock과 선점**
    
    Spin Lock을 사용하는 스레드는 **CPU를 점유하며 플래그를 계속 확인하는 루프를 반복**합니다. 이 과정에서 운영 체제가 어떻게 동작하는지에 따라 선점 여부가 달라질 수 있습니다:
    
    1. **선점형 환경 (Preemptive Multitasking)**:
        - 운영 체제의 스케줄러는 특정 스레드가 CPU를 지나치게 오래 점유하면 강제로 선점할 수 있습니다.
        - 하지만 Spin Lock은 매우 짧은 시간 동안 락이 해제될 것을 가정하고 설계되므로, **스케줄러가 개입할 가능성이 낮습니다**.
        - 따라서 스레드가 Spin Lock을 돌고 있는 동안, 이론적으로는 선점이 가능하지만, 락 대기 시간이 짧다면 실제로 선점이 발생하지 않을 가능성이 큽니다.
    2. **비선점형 환경 (Non-Preemptive Multitasking)**:
        - 비선점형 환경에서는 스레드가 명시적으로 CPU를 양보하지 않는 한 선점이 발생하지 않습니다.
        - Spin Lock을 사용하는 스레드가 CPU를 점유하고 있다면, **다른 스레드로의 전환이 불가능**합니다.
        - 이런 환경에서는 Spin Lock이 **완전히 비선점형**으로 동작합니다.
    
    ---
    
    ### **Spin Lock이 선점형 환경에서 비선점형처럼 보이는 이유**
    
    Spin Lock이 동작 중일 때, 스케줄러가 스레드를 강제로 전환하지 않는 주된 이유는 다음과 같습니다:
    
    1. **짧은 대기 시간**:
        - Spin Lock은 락이 빠르게 해제될 것을 가정하므로, 컨텍스트 스위칭으로 인한 오버헤드가 더 크다고 판단합니다.
        - 결과적으로, 락 대기 중인 스레드가 선점 없이 CPU를 계속 점유합니다.
    2. **스케줄러 정책**:
        - 운영 체제는 CPU를 점유하고 있는 스레드가 Spin Lock을 사용 중인 것을 감지하고, 선점을 유예할 수 있습니다.
        - 스케줄링 정책에 따라 Spin Lock 대기 중인 스레드는 우선순위가 낮은 상태로 간주되지 않을 수 있습니다.
    3. **CPU 사용 루프**:
        - Spin Lock은 CPU를 계속 사용하기 때문에, 다른 스레드가 실행될 기회가 줄어듭니다. 스케줄러가 선점을 시도하더라도 CPU 점유를 해제하지 않는 한 Spin Lock 스레드는 계속 실행됩니다.
</aside>

- 단점 해결  : 하이브리드 락  - 스핀락과 블로킹 락의 장점을 결합한 하이브리드 락을 사용한다.
스레드가 일정 시간동안 스핀을 시도하고 그후에도 락을 얻지 못하면 블록 상태, 짧은 대기는 스핀으로 긴대기 시간에는 CPU자원 절약
- 적응형 스핀 락 : 락의 사용패턴에 따라 스핀 시간의 길이를 동적으로 조정, 락이 짧은 시간 내에 해제 될 가능성 높다면 스핀 시간을 길게 그렇기 않다면 짧게
- 우선 순위 상속  : 스핀 락 루프 내에서 PAUSE명령어와 같은 CPU휴식 명령어 사용하여 CPU낭비를 줄인다.
- 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?
    - 시스템 콜의 장점인 안전성 - 커널에서 관리 되기 때문에 동기화 매커니즘이 안정적이다.
    - 커널은 세마포어등의 기법을 통해 공정한 자원분배를 보장할 수 있다.
    - 커널 수준에서 우선순위 상속 기법같은 우선 순위 역전 문제를 해결하기 위한 기법들을 효과적으로 적용할 수 있다.
    - 커널은 프로세스간 동기화를 지원하기 때문에 같은 시스템 내의 여러 프로세스가 동일한 락을 사용할 수있다.
    - 단점 :  시스템 콜은 사용자 모드에서 커널 모드로 전환이 반복되며 , 상당한 오버헤드가 발생할 수 있다.
    - 락을 얻기위해 블록 될 경우 컨텍스트 스위칭이 발생하여 추가적인 성능 저하가 발생 할 수있다.
    - 커널 수준에서 동기화를 관리하기 때문에 구현과 유지보수가 어려울 수 있다
    - 단점 해결 :
    - 스핀락 : 간단한 경우에는 스핀 락을 사용하여 사용자 모드에서 락을 관리할 수 있다. 이는 시스템 콜의 오버헤드를 피할 수 있지만, 스핀 락의 단점을 해결해야 한다.
    - **배리어 락:** 사용자 모드에서 구현된 배리어를 사용하여 특정 조건이 만족될 때까지 대기하는 방식으로, 시스템 콜의 빈도를 줄일 수 있습니다
    - **락 스트리핑(Lock Stripping)**: 해시 테이블 등의 구조에서, 각 버킷에 별도의 락을 적용하여 경합을 줄이는 방식이다.

참고 : [https://hogwart-scholars.tistory.com/entry/OS-Spin-Lock-스핀락에-대해-알아보자](https://hogwart-scholars.tistory.com/entry/OS-Spin-Lock-%EC%8A%A4%ED%95%80%EB%9D%BD%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90)