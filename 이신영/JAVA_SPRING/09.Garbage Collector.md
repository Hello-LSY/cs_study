## Java의 GC에 대해 설명해 주세요.

자바의 가비지 컬렉션(GC)은 힙 영역에 동적으로 할당되었으나 더 이상 참조되지 않는 객체들을 탐지하여 메모리에서 해제하는 JVM의 기능입니다. 이를 통해 개발자는 메모리 누수에 대해 신경 쓰지 않아도 됩니다. 메모리를 관리하는 여러 알고리즘이 있는데 대표적으로는 Mark and Sweep을 이용하는 방법이 있습니다.

Mark and Sweep: GC는 먼저 모든 객체를 스캔하고, 도달 가능한(reachable) 객체들을 마킹합니다. 이후 마킹되지 않은 객체들을 제거하여 메모리를 회수합니다.

### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?

finalize() 메소드는 객체가 가비지 컬렉션될 때 JVM에 의해 자동으로 호출되도록 설계되었습니다. 이를 수동으로 호출하면 객체가 여전히 유효한 상태에서(NULL이 아닌 상태) finalize() 메소드가 실행되어 예기치 않은 동작을 초래할 수 있습니다. 이는 재참조 가능성을 가지고 메모리의 일관성을 해칠 수 있습니다. 

또한 finalize()의 호출시점은 GC에 의해 결정되기때문에 사용자는 이를 예측 할 수 없고 수동으로 호출한다해도 호출시점에 바로 실행되지않기때문에 프로그램의 동작이 불안정해질 수 있습니다. 

마지막으로 finalizer는 finalize()를 호출하는 과정에서 추가적인 오버헤드를 발생시키기 때문에 전체 GC 성능을 저하시킬 수 있습니다.

### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?

네, 어떤 변수의 값이 null로 설정되면, 해당 변수는 더 이상 이전에 참조하던 객체를 가리키지 않게 되고 GC될 준비가 된 상태라고 할 수 있습니다.

이로 인해 그 객체는 가비지 컬렉터에 의해 수거될 가능성이 높아집니다. GC는 더 이상 참조되지 않는 객체를 탐지하여 메모리에서 해제하기 때문에, null로 설정된 객체는 가비지 컬렉션의 대상이 될 수 있습니다.

따라서, 객체를 null로 설정하는 것은 GC가 객체를 수거할 수 있는 조건을 마련해 주지만, GC 실행 시점과 실제 메모리 해제는 JVM의 결정에 따르게 됩니다.

[출처-본인](https://velog.io/@sin_0/Java-GCGarbage-Collector%EB%9E%80)
