## 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?

1. Round Robin (RR): 공정한 시간 분배, 멀티태스킹에서 자주 사용.
2. First-Come, First-Served (FCFS): 간단한 FIFO 방식, 배치 처리에 적합.
3. Shortest Job First (SJF): 평균 대기 시간 최소화, 기아 문제 발생 가능.
4. Priority Scheduling: 중요한 작업 우선 처리, 실시간 시스템에 사용.
5. Multilevel Feedback Queue (MLFQ): 다양한 프로세스 특성 처리, 범용 운영체제에 사용.

### RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.

Time Slice가 짧을 때:

장점: 시스템 응답성이 좋아집니다. 각 프로세스가 자주 CPU 시간을 얻기 때문에 사용자가 빠른 응답을 경험할 수 있습니다.
단점: 빈번한 컨텍스트 스위칭으로 인해 오버헤드가 증가합니다. 컨텍스트 스위칭은 시간이 소모되며, CPU가 실제 작업을 수행하는 시간보다 스위칭에 더 많은 시간을 소모할 수 있습니다.

Time Slice가 길 때:

장점: 컨텍스트 스위칭 오버헤드가 줄어듭니다. 프로세스가 더 오랜 시간 동안 CPU를 사용하기 때문에 스위칭 빈도가 낮아집니다.
단점: 응답 시간이 길어집니다. 긴 시간을 기다려야 하므로 시스템이 즉각적인 반응을 제공하지 못할 수 있습니다.

### 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

상시로 돌아가야 하는 프로세스는 일반적으로 우선순위가 높은 작업(예: 실시간 데이터 처리, 시스템 모니터링 등)입니다. 때문에 우선순위 혹은 실시간 스케줄링 알고리즘이 적합합니다.

> Priority Scheduling : 우선순위가 높은 프로세스를 먼저 실행함으로써 이러한 작업이 항상 필요한 CPU 시간을 얻을 수 있도록 보장합니다.
>
> Real-Time Scheduling: 일정 시간 안에 작업을 반드시 완료해야 하는 실시간 요구가 있는 경우, 정해진 시간 내에 프로세스를 실행하고 완료할 수 있도록 보장할 수 있습니다.

### 동시성과 병렬성의 차이에 대해 설명해 주세요.

동시성(Concurrency):
여러 작업이 동시에 진행되는 것처럼 보이도록 하는 개념입니다. 실제로는 하나의 CPU가 빠르게 전환하며 여러 작업을 처리하는 방식입니다. 멀티태스킹에서 사용됩니다. 예를 들어, 싱글 코어 시스템에서 스레드가 시분할로 실행되는 경우를 생각할 수 있습니다.

병렬성(Parallelism):
여러 작업이 실제로 동시에 실행되는 것을 의미합니다. 다수의 CPU 코어나 프로세서를 사용하여 여러 작업을 동시에 수행하는 방식입니다. 예를 들어, 멀티코어 CPU에서 여러 스레드가 동시에 실행되는 경우가 있습니다.

### 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?

프로세스의 우선순위를 동적으로 조절하며, 오랜 시간동안 대기한 프로세스의 우선순위를 높여서 스타베이션을 완화할 수 있습니다. 또한 CPU를 많이 사용하는 프로세스는 낮은 우선순위로 이동하고, 빠르게 끝나는 프로세스는 높은 우선순위를 유지할 수 있습니다.

> Starvation(기아) : 일부 프로세스가 계속해서 높은 우선순위로 실행되면서 다른 프로세스들이 낮은 우선순위로 계속해서 대기하는 상황

### FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

응용프로그램이 단순히 모든 작업이 동일한 중요성을 가지고있고 순서대로 처리해야하는 경우에 컨텍스트 스위칭 비용이 최소화되기때문에 적합합니다.

### 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

운영체제의 스케줄러는 프로세스와 스레드를 모두 스케줄링하여 CPU 시간을 할당합니다.

차이점은 스레드는 같은 프로세스 내에서 실행되며, 메모리 공간과 자원을 공유하기 때문에, 스레드 간의 전환은 더 빠르고 비용이 적습니다.


### 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

유저 스레드는 커널이 아닌 사용자 공간에서 관리되므로, 스케줄링이 더 빠르고 가볍지만, 커널이 아닌 사용자 레벨의 스레드 라이브러리에서 관리되기 때문에 블록된 스레드가 전체 프로세스에 영향을 미칠 수 있습니다.

반면 커널 스레드는 커널이 개별적으로 관리하여 보다 세밀한 제어가 가능하고, 스레드가 독립적으로 관리되기 때문에 블록된 스레드가 다른 스레드에 영향을 미치지 않습니다. 다만, 커널에서 관리로 인해 스케줄링 오버헤드가 더 큽니다.

> 유저스레드가 더 빠른 이유 : 유저 스레드 라이브러리 자체가 스레드의 레지스터 상태, 스택 포인터 등을 저장하고 복구하는 방식으로 전환. 이 과정은 커널 모드로 전환되지 않고, 유저 모드에서 이루어지기 때문에 상대적으로 가볍고 빠르다.

