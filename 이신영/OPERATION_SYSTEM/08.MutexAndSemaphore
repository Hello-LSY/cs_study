## 뮤텍스와 세마포어의 차이점은 무엇인가요?

뮤텍스는 하나의 하나의 자원에 대해 하나의 소유권(락)만을 가지는 이진 상태로, 자원을 소유한 스레드만이 락을 해제할 수 있습니다. 반면, 세마포어는 소유권의 개념이없고 여러자원에 대한 동시접근을 세마포어의 정수값으로 제어합니다.

이러한 구조로 인해, 가장 큰 차이는 어떤환경에서 유리한가 라는 점에서 뮤텍스는 단일자원에서 유리하고 세마포어는 동시에 접근할 수 있는 자원이 여러개일 때 유리합니다.

> 임계구역 : 병렬컴퓨팅에서 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원

### 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.

일반 세마포어는 0과 1이상의 값을 가질 수 있는 반면 이진 세마포어는 뮤텍스와 유사하게 0과 1만을 가지지만 소유의 개념이 없어 자원을 소유하지 않은 스레드도 세마포어 값을 변경할 수 있습니다.

### Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?

CPU가 직접 락을 얻기 위해 대기(Busy Waiting)를 하기 때문에 컨텍스트 스위칭이 발생하지 않습니다.(= 오버헤드가 적기 때문에 락이 오래걸리지않고 해제가 빠르다면 효율이 좋다) 다만 자원을 획득할때까지 CPU를 사용하여 지속적으로 락을 확인한다는 점입니다.
즉, 대기 시간이 길어질수록 CPU의 자원누수가 심해집니다. 단점을 해결하는 방법으로는 대부분 발생하는 단점상황은 뮤텍스를 사용하여 대기시간문제를 해소할 수 있다고 생각합니다.

### 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

자원관리를 시스템콜을 통해 커널이 하는만큼 안전성을 보장하지만 오버헤드가 발생하는 과정에서의 비용이 단점입니다. 결론은 시스템콜의 수를 줄여야하는건데 이를 해소하는방법으로는 유저스페이스 락을 사용하여 유저모드에서 락을 관리하는 방법입니다. 

이에 대한 예시로는 CAS(Compare-and-Swap)나 Fetch-and-Add가 있습니다.

> Compare-and-Swap (CAS): 특정 메모리 위치의 값을 읽고, 예상된 값과 비교한 후, 값이 일치하면 새로운 값으로 원자적으로 변경하는 연산. 
> Fetch-and-Add: 특정 메모리 주소의 값을 읽고, 그 값을 일정 크기만큼 더한 후 새로운 값을 저장하는 원자적 연산

