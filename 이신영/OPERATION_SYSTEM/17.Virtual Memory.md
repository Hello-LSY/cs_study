# 가상 메모리란 무엇인가요?

가상 메모리는 프로세스가 사용하는 주소 공간을 실제 물리 메모리 크기에 구애받지 않고 확장할 수 있도록 설계된 메모리 관리 기법입니다. 운영체제가 디스크를 활용해 물리 메모리를 보완하고, 프로그램이 필요한 데이터를 필요한 시점에만 물리 메모리에 적재함으로써 메모리를 효율적으로 사용할 수 있게 합니다. 이를 통해 메모리 부족 문제를 완화하고, 다중 프로세스 실행 시 시스템의 안정성과 성능을 유지합니다.
## 가상 메모리가 가능한 이유가 무엇일까요?

가상 메모리가 가능한 이유는 하드웨어와 소프트웨어의 협업덕분입니다. 

1. MMU(Memory Management Unit): CPU와 메모리 사이에서 논리 주소를 물리 주소로 변환하는 하드웨어 장치입니다. 이를 통해 가상 주소와 실제 메모리 주소 간의 매핑이 가능합니다.
2. 페이지 기반 메모리 관리: 운영체제가 메모리를 고정된 크기의 페이지 단위로 관리하며, 각 페이지는 독립적으로 물리 메모리에 매핑될 수 있습니다.
3. 스왑 공간: 디스크의 일부를 스왑 공간으로 활용해 물리 메모리 크기를 초과하는 주소 공간을 제공합니다.
4. 운영체제의 페이지 테이블 관리: 운영체제가 각 프로세스의 가상 주소와 물리 주소 매핑 정보를 효율적으로 관리하기 때문에 프로세스 간의 충돌을 방지하고 가상 메모리를 지원할 수 있습니다.

## Page Fault가 발생했을 때, 어떻게 처리하는지 설명해 주세요.

Page Fault는 프로세스가 참조하려는 페이지가 물리 메모리에 존재하지 않을 때 발생하는 이벤트입니다.

1. **Page Fault 인터럽트 발생**
   - CPU는 해당 참조를 처리할 수 없으므로 운영체제에 인터럽트를 요청합니다.
2. **페이지 존재 여부 확인**
   - 운영체제는 페이지 테이블을 참조해 요청한 페이지가 디스크에 존재하는지, 아니면 잘못된 참조(Invalid Reference)인지 판단합니다.
3. **페이지 로드 수행**
   - 디스크에 존재하는 페이지라면, 물리 메모리에 빈 프레임을 확보하거나 페이지 교체 알고리즘(e.g., LRU, FIFO 등)을 통해 기존 페이지를 교체합니다.
   - 페이지를 물리 메모리에 적재합니다.
4. **페이지 테이블 업데이트**
   - 새로운 페이지의 물리 주소를 페이지 테이블에 기록하고, 해당 페이지를 유효한 상태로 설정합니다.
5. **프로세스 재개**
   - 중단되었던 프로세스는 Page Fault 처리 이후 명령어를 다시 실행합니다.

## 페이지 크기에 대한 Trade-Off를 설명해 주세요.

- **페이지 크기가 작을 경우**
  - **장점**
    - 메모리 낭비(내부 단편화)가 최소화됩니다. 실제로 필요한 데이터만 물리 메모리에 적재하므로 자원을 효율적으로 사용합니다.
  - **단점**
    - 페이지 테이블 크기가 커집니다. 많은 페이지를 관리해야 하므로 테이블 오버헤드와 주소 변환 시간이 증가합니다.
    - 디스크 I/O가 빈번해져 성능이 저하될 수 있습니다.

- **페이지 크기가 클 경우**
  - **장점**
    - 페이지 테이블 크기가 작아지고, 디스크에서 메모리로의 데이터 전송이 더 효율적입니다. 큰 단위로 읽어들임으로써 I/O 성능을 향상시킬 수 있습니다.
  - **단점**
    - 메모리 낭비(내부 단편화)가 증가합니다. 실제로 필요한 데이터보다 더 큰 페이지가 로드되면서 비효율이 발생할 가능성이 높습니다.

## 페이지 크기가 커지면, 페이지 폴트가 더 많이 발생한다고 할 수 있나요?

페이지 크기가 커질수록 일반적으로 페이지 폴트는 감소합니다. 이는 큰 페이지 크기 덕분에 한 번의 페이지 로드로 더 많은 데이터가 메모리에 적재되어 참조 지역성(Locality of Reference)을 더 효과적으로 활용할 수 있기 때문입니다.

다만, 불필요한 데이터까지 메모리에 로드되는 경우 내부 단편화가 발생하며, 전체 메모리 사용 효율은 저하될 수 있습니다. 혹은, 과도하게 큰 페이지 크기를 설정하면, 오히려 물리 메모리의 가용량이 제한되거나 빈번한 페이지 교체로 이어질 수 있습니다.

## 세그멘테이션 방식을 사용하고 있다면, 가상 메모리를 사용할 수 없을까요?

상호배타적인 개념이 아니기 때문에 결합해서 가능합니다.

1. 세그먼트를 다시 페이지 단위로 나누어 관리하면, 세그멘테이션의 논리적 메모리 구분 장점과 페이징의 물리 메모리 관리 효율성을 동시에 활용할 수 있습니다.
2. 세그멘테이션 테이블과 페이지 테이블을 조합해 가상 주소를 물리 메모리로 매핑할 수 있으며, 이 경우 각 세그먼트 내 페이지가 독립적으로 스왑 인/아웃됩니다.
