# 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요. 

동기(Synchronous)

- 작업을 요청하면 작업이 완료될 때까지 기다립니다.
- 요청과 결과가 시간적으로 연결되어 있습니다.
- 예) 은행에서 순서대로 창구를 이용하는 상황.

비동기(Asynchronous)

- 작업을 요청하면 작업 완료를 기다리지 않고, 다른 작업을 수행할 수 있습니다.
- 요청과 결과가 시간적으로 독립적입니다.
- 예) 음식점에서 주문 후 호출벨을 받고, 음식을 받을 때까지 다른 일을 하는 상황.

## 그렇다면, 동기이면서 논블로킹이고, 비동기이면서 블로킹인 경우는 의미가 있다고 할 수 있나요? 

동기이면서 논블로킹은 의미가 있습니다. 호출자는 요청을 보낸 후 결과를 기다리지 않지만, 작업 상태를 계속 확인(polling)해야 하므로 동기적으로 작동합니다.

비동기이면서 블로킹인 경우는 의미가 없습니다. 비동기는 작업 완료를 기다리지 않는 것이 특징인데, 블로킹은 기다리는 개념이므로 충돌합니다. 그러나 결과를 강제로 기다려야 하는 경우는 제한적으로 사용될 수 있습니다.

블로킹(Blocking)

- 요청을 보낸 후 결과를 받을 때까지 대기합니다.
- 호출한 함수가 완료될 때까지 제어권이 호출자에게 반환되지 않습니다.
- 예) 전화를 걸고 상대방이 받을 때까지 기다리는 상황.

논블로킹(Non-Blocking)

- 요청을 보낸 후 결과를 기다리지 않고 즉시 반환합니다.
- 호출한 함수는 작업이 완료되지 않아도 제어권을 반환합니다.
- 예) 문자 메시지를 보내고 상대방이 답장을 보내는 동안 다른 일을 하는 상황.

## I/O 멀티플렉싱에 대해 설명해 주세요. 

I/O 멀티플렉싱은 여러 I/O 작업을 동시에 처리하기 위한 기술입니다. 하나의 스레드가 여러 파일 디스크립터(소켓, 파일 등)를 감시하여 작업 가능 여부를 확인하고, 준비된 작업만 수행합니다.

예로 채팅 서버에서 여러 클라이언트가 연결될 때, 모든 연결을 하나씩 확인하는 대신, 준비된 연결만 처리합니다.

## 논블로킹 I/O를 수행한다고 하면, 그 결과를 어떻게 수신할 수 있나요?

Polling
- 작업이 완료되었는지 주기적으로 확인합니다.
- 단점: 자원을 낭비할 수 있음.
- 예) 이메일 답장 왔나 계속 새로고침

Callback

- 작업이 완료되면 콜백 함수를 호출합니다.
- 장점: 효율적이고, 대기하지 않음.
- 예) 전화오면 알림음으로 알려주는 방식

Future/Promise:

- 결과를 비동기적으로 반환받을 수 있는 객체.
- 작업이 완료될 때까지 객체를 통해 상태를 확인하거나 결과를 가져옵니다.
- 예) 택배 추적 시스템에서 "배송 완료" 상태를 확인하는 방식.

Event-Driven 방식:

- 이벤트 루프를 통해 작업이 완료되면 알림을 받습니다.
- Node.js와 같은 이벤트 기반 환경에서 주로 사용
