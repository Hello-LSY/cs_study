## **JPA와 같은 ORM을 사용하는 이유가 무엇인가요?**

ORM은 데이터베이스와 객체 지향 프로그래밍 언어 사이의 관계를 관리하기 위해 사용됩니다.

JPA Object Relation Mapping → 데이터베이스의 테이블 즉 엔티티와 JAVA 객체를 매핑시키는 ORM 기술입니다.

쿼리를 직접 작성할 필요없이 객체의 메소드를 사용하여 데이터베이스에서 갱신 삽입 등의 연산을 실행합니다.



## 꼬리질문

### 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?

영속성이란 데이터를 생성한 프로그램이 종료 되더라도 사라지지 않는 데이터의 특성을 의미합니다.

영속성 컨텍스트는 DB와 응용 어플리케이션 사이의 가상 데이터베이스와 같은 역할(1차 캐시)을 합니다.

EntityManager을 통해 엔티티를 조회하거나 삽입하면 영속성 컨텍스트에 엔티티를 보관하고 관리하게 됩니다.

엔티티의 생명주기

- 비영속
    - 엔티티를 생성은 했지만, 아직 영속성 컨텍스트에 존재하지 않는 상태
- 영속
    - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장한 상태
    - 영속성 컨텍스트에 의해 관리되며, 아직 DB에 저장되지않음
- 준 영속
    - 영속성 컨텍스트에 저장되었다가 분리된 상태
    - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티 → 더이상 관리하지 않음
- 삭제
    - 엔티티를 영속성 컨텍스트와 DB에서 삭제함.
    

1차 캐시란 영속성 컨텍스트 내부에 존재하는 캐시이며 영속 상태의 엔티티를 캐시에 저장합니다.

key - value 형식의 맵 자료구조로 저장되어 있습니다. 여기서 Key는 당연하게도 해당 테이블의 Primary KEY가 됩니다. value는 엔티티 객체의 주소를 가르키고있습니다.

1차 캐시에서 엔티티를 찾고, 없으면 데이터베이스에서 조회합니다. 데이터베이스에서 조회 완료되면 영속성 컨텍스트에 조회된 데이터도 저장됩니다.

데이터의 삽입 삭제 등의 연산이 이루어질 때 엔티티 객체만 영속성 컨텍스트에 저장되는 것이 아니라 SQL저장소에 SQL문이 같이 저장됩니다. 그리고 한 트랜잭션 즉 commit()이 발생할 때 SQL저장소에 저장되어 있는 sql문들이 동시에 실행됩니다.  

JPA에서 영속성 컨텍스트에서 관리하고 있는 엔티티를 조회하면 해당 엔티티의 첫 조회 상태로 스냅샷을 만들어 놓는데, 이를 현재의 값과 비교하여 dirtyChecking이 진행됩니다.

1차 캐시란 말은 성능에 큰 도움이 될 것 같지만 사실 성능 면에 있어 큰 도움이 되진 않습니다. 해당 1차 캐시의 생명주기는 트랜잭션 단위에서 생성되고 삭제되기 때문에 한 트랜잭션 내에 한 엔터티 객체를 여러번 조회하는 경우에는 성능면에서 큰 도움이 될 수 있습니다.

동일성

한 트랜잭션에서 특정 엔터티 인스턴스를 두 번 조회할 때 첫 번째에 디비에서 조회하면서 영속성 컨텍스트에 엔터티 객체가 저장되고 두 번째로 조회할 때 1차 캐시에 있는 객체를 찾으므로 같은 객체를 참조하여 두 객체간의 동일성을 보장합니다. 

```java
Member a = em.find(Member.class, "member");
Member b = em.find(Member.class, "member");
System.out.print(a==b) // true
```

### N + 1 문제에 대해 설명해 주세요.

N+1 문제는 연관관계가 설정된 엔터티 사이에서 한 엔터티를 조회하였을 때, 해당 엔터티와 연관된 다른 엔터티를 조회하기 위해 추가적인 쿼리가 실행되는 상황을 말합니다.

- fetch join
    - 지연로딩의 해결책
    - 사용될 때 확정된 값을 한번에 join에서 select해서 가져옴
    - Pagination이나 2개 이상의 collection join에서 문제가 발생
