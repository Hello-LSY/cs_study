## 프로세스가 무엇인가요?

프로세스는 실행중인 프로그램을 의미합니다. 각 프로세스는 각자의 메모리영역을 갖고있고 메모리 가상화를 통해 서로의 메모리 영역에 침범할 수 없도록 보장합니다. 메모리영역은 크게 Instruction code, Data영역, Heap 영역, Stack 영역 으로 이루어져 있습니다.

프로세스 내부에는 최소 하나의 스레드를 보유 하고 있습니다.

## 꼬리질문

### 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.

-   **프로그램(Program)**: 디스크에 저장된 정적인 코드와 데이터를 의미합니다. 실행되지 않은 상태의 단순한 파일에 불과합니다.
-   **프로세스(Process)**: 프로그램이 메모리에 로드되어 실행되고 있는 상태를 의미합니다. 프로세스는 프로그램의 실행 중에 필요한 자원들을 가지고 있으며, 독립적인 메모리 공간(주소 공간)을 가집니다.
-   **스레드(Thread)**: 프로세스 내에서 실행되는 하나의 실행 흐름입니다. 프로세스는 하나 이상의 스레드를 가질 수 있으며, 여러 스레드가 동일한 메모리 공간을 공유합니다. 스레드는 프로세스의 경량 단위로, 같은 프로세스 내의 스레드들은 서로 데이터를 공유할 수 있습니다.

### PCB가 무엇인가요?

Process Controll Block (PCB) 는 특정한 하나의 프로세스를 관리할 때 필요한 정보들이 저장되어 있습니다.

운영체제의 커널스페이스에 저장되는 자료구조로, 프로세스를 표현하는 정보들을 가지고 있습니다.

-   Pointer
-   Process State
-   PID
-   registers
-   Program Count
-   memory limits
-   list of open files

등 다양한 정보를 포함하고 있습니다.

### 그렇다면, 스레드는 PCB를 갖고 있을까요?

PCB에서 내부적으로 TCB를 관리하고 있습니다. 이를 통해 멀티스레드 환경을 생성할 수 있고 스레드가 늘어날 때 TCB도 확장됩니다.

TCB

-   Thread ID
-   Thread State
-   CPU INFORMATION
    -   Program Counter
    -   Register
-   Thread Priority
-   부모 프로세스 Pointer
-   자식 Threads 정보

스레드끼리는 Code 영역 data 영역, heap영역은 공유하며, 개별의 stack 영역을 갖게 됩니다.

데이터 영역을 공유하므로 동기화를 잘 해줘야 합니다.

### 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?

기본적으로 프로그램을 실행하면 해당 프로그램을 실행하는 프로세스가 생성되고, fork() 시스템 콜을 사용해 한 프로그램 내에서 또 다른 자식 프로세스를 생성해 멀티 프로세싱이 가능합니다.

fork(), exec() 차이점

fork() 는 새로운 Pid를 받고 부모의 메모리 영역을 그대로 복사하여 새로운 프로세스가 생성됩니다. (code, pc, register 등)

Exec() 은 해당 시스템 콜을 호출한 프로세스가 Exec() 시스템 콜로 실행한 프로그램의 새로운 프로세스로 초기화되며 pid는 기존 pid를 유지합니다.

보통 멀티 프로세싱할 때 fork () + Exec() 방식을 사용하기도 합니다.

스레드는 pthread_create() 시스템 콜을 사용해 생성됩니다. 리눅스에서 스레드는 내부적으로 clone() 시스템 콜을 사용해 구현됩니다. clone() 메소드는 부모 프로세스의 주소 공간을 공유하는 새로운 스레드를 생성하며, 이 스레드들은 메모리와 자원을 공유하면서도 독립적으로 실행됩니다.

### 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

자식 프로세스가 상태를 알리지 않고 죽는 경우는 주로 “좀비 프로세스”라고 합니다. 좀비 프로세스는 PCB만 남게되어 메로리 자원을 낭비하게 됩니다. 부모 프로세스는 wait() 이나 waitpid() 시스템 콜을 사용하여 자식 프로세스의 종료 상태를 조회하여 좀비 프로세스 상태를 해제할 수 있습니다.

부모 프로세스가 먼저 죽는 경우에 자식 프로세스는 고아 프로세스가 되게 됩니다. 이러한 경우에 자식 프로세스는 자동으로 init (pid =1) 인 루트 프로세스의 자식이 되어 init 프로세스의 관리를 받아 좀비 프로세스가 되지 않도록 합니다.

### 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

데몬 프로세스란 백그라운드에 실행되어 사용자와 직접적인 상호작용 없이 시스템이 원활하게 작동할 수 있도록 특정 작업이나 서비스를 수행하는 프로세스입니다. 예를들어 프로세스를 관리하는 init 프로세스가 데몬 프로세스에 속한다고 볼 수 있습니다.

데몬 프로세스는 일반적으로 시스템이 부팅될 때 시작되어, 시스템이 종료될 때까지 계속 실행됩니다. 데몬 프로세스는 일반 프로세스와 달리 터미널로부터 분리된 상태에서 실행됩니다.

### 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

리눅스에서 모든 프로세스는 일종의 트리 구조를 형성하고 있으며, 이 트리의 루트에 위치한 프로세스가 바로 **`init` 프로세스**입니다. `init` 프로세스는 시스템 부팅 시 가장 먼저 실행되며, 모든 다른 프로세스는 `init` 프로세스의 자식 또는 그 후손입니다.

OS 동작시 필요한 환경값들을 설정해주고 이에 필요한 Process들을 실행시켜주는 역할을 합니다.
